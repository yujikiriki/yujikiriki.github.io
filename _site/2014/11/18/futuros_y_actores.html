<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bliki | Futuros y actores en Scala y Akka</title>
    <link rel="stylesheet" href="http://yujikiriki.github.io/css/foundation.css" />
    <script src="http://yujikiriki.github.io/js/vendor/modernizr.js"></script>
  </head>
  <body>
<!-- Page begins  -->
  <div class="row bottom-border">
    <div class="large-11 columns">
      <h1><small><a href="http://yujikiriki.github.io/index.html">_bliki</a></small></h1>
    </div>
  </div>
  <div class="row">
    <div class="large-8 columns">
      <div class="row">
        <div class="large-12 columns">
          <br/>
          <h2>FUTUROS Y ACTORES EN SCALA Y AKKA</h2>
          <h6 class="subheader">Por: <a href="https://s3.amazonaws.com/bitacora/me.html">Miguel Vila, Yuji Kiriki</a></h6>
          <h6 class="subheader">Publicado: November 18, 2014</h6>
          <h6 class="subheader">Número de palabras: 1788</h6>
          <h6 class="subheader">Categorías: </h6>
        </div>
      </div>
      <br/><br/>
      <p>Tradicionalmente, construir aplicaciones que soporten concurrencia en la JVM siempre ha sido problema del servidor de aplicaciones. Pocas veces nos veíamos en la tarea de implementar o de pensar en problemas de semáforos, hilos y procesos y, cuando teníamos que hacerlo, es porque el servidor de aplicaciones no daba más.</p>

<p>El número de usuarios y de aplicaciones integradas de hoy nos ha llevado a buscar alternativas ligeras y más adecuadas para soportar crecimientos súbitos en la demanda de recursos, de conexiones y de la disponibilidad misma de las aplicaciones; permitiendo dar respuestas correctas en un tiempo tolerable.</p>

<p>Los Futuros en Scala (implementados <a href="http://docs.scala-lang.org/overviews/core/futures.html">en</a> <a href="https://github.com/scalaz/scalaz">varias</a> <a href="https://twitter.github.io/finagle/">librerías</a>) y el modelo de actores en Akka, permiten modelar e implementar soluciones que aprovechan las características del hardware moderno: múltiples núcleos de procesamiento, centenas de miles de megas de memoria; redundando en la capacidad de soportar concurrencia aumentando su disponibilidad y comportamiento correcto.</p>

<p>Los beneficios no solo se miden a través del desempeño de una solución. El nivel de abstracción en el que se razona sobre Futuros o actores permite diseñar y escribir código concurrente y paralelo, de fácil lectura, que atiende la concurrencia de manera elegante y digerible.</p>

<p>Por estos hechos y razones, consideramos compartir una análisis a través de la cual puedan hacer la elección de la herramienta más adecuada para sus escenarios donde se presente concurrencia, proponiendo y promoviendo así el “fin de vida” de lo servidores de aplicaciones.</p>

<h3 id="cundo-actores">Cuándo Actores</h3>

<p>La mayor ventaja del modelo de actores sobre los futuros es su capacidad de mantener estado y protegerlo de la concurrencia. Si a esta propiedad se le suma su similitud con la noción de objetos del paradigma orientado a objetos (OO), las soluciones que se pueden implementar son simples y potentes.</p>

<p>Lo simple nace del fomento de la <a href="https://s3.amazonaws.com/bitacora/2013/04/13/simpatia_semantica.html">simpatía semántica</a> al combinar el modelo de actores con los principios del diseño OO. Esta combinación puede entenderse como un <a href="http://en.wikipedia.org/wiki/Mutualism_(biology)">mutualismo</a> donde, en la solución de software, el modelo de actores se ve fortalecido por OO y OO se ve enriquecido por el modelo de actores.</p>

<p>El mutualismo se fundamenta en la noción de estado de los actores y de los objetos. Al ser dos ideas análogas, se pueden aplicar los principios de OO en el diseño de los actores, siendo cada uno de ellos interpretados como objetos que protegen su encapsulamiento a través del intercambio de mensajes.</p>

<p>En una <a href="http://www.drdobbs.com/architecture-and-design/interview-with-alan-kay/240003442?pgno=3">entrevista</a>, Alan Kay (para algunos el fundador del paradigma objetual), admite esta relación:</p>

<blockquote>
  <p><strong>Binstock:</strong> How do you view the Actor model?</p>
</blockquote>

<blockquote>
  <p><strong>Kay:</strong> The first Smalltalk was presented at MIT, and Carl Hewitt and his folks, a few months later, wrote the first Actor paper. The difference between the two systems is that the Actor model retained more of what I thought were the good features of the object idea, whereas at PARC, we used Smalltalk to invent personal computing. It was actually a practical programming language as well as being interesting theoretically. I don’t think there were too many practical systems done in Actors back then.</p>
</blockquote>

<p>Cabe notar que OO es un paradigma de programación mientras que los actores son un modelo de computación. No obstante, la noción de estado sirve como articulador entre ellas.</p>

<p>Ahondando en esta relación por el lado OO, podemos hacer uso de las prácticas de <em>Domain-Driven Design</em>. Los patrones tácticos son fácilmente implementados en el modelo de actores permitiendo tener grafos de actores que modelan dominios de negocio. No solo ahí se fomenta el mutualismo. Si hacemos uso de los actores como <a href="http://dspace.mit.edu/handle/1721.1/6952">modelo de concurrencia para sistemas distribuidos</a>, podemos escribir aplicaciones de software que implementan modelos de dominio listos para soportar concurrencia y para ser distribuidos en una red. Quizás, esta última, sea la característica de más potencial de los actores sobre los futuros.</p>

<p>Otra ventaja de los actores sobre los futuros es la capacidad de distribuir trabajo sobre un sistema distribuido. A través de sus principios, el modelo de actores permite distribuir no solo concurrencia sino carga en varios nodos, permitiendo la presencia de procesamiento paralelo. No obstante, hay investigación de cómo tener funciones distribuidas.</p>

<p>Es necesario recordar que el modelo de actores no es un artefacto de la programación funcional. Sin embrago desde el punto de vista de la programación funcional, los actores adolecen de:</p>

<ul>
  <li>No determinismo: no hay garantía en la entrega de mensajes entre actores.</li>
  <li>Implican side effects y tener una visión no local del sistema, lo que implica que no se puedan componer.</li>
  <li>Los actores en Akka rechazan la unidad básica de modularidad: las funciones con efectos <code>A =&gt; B</code> por funciones con <em>side effects</em> <code>Any =&gt; Unit</code>.</li>
</ul>

<h3 id="cundo-futuros">Cuándo Futuros</h3>

<p>Los futuros son una abstracción que sirve para representar acciones asíncronas. Pueden ser vistos como un mecanismo para manejar asincronía <a href="https://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/">un nivel de abstracción por encima de usar <em>callbacks</em></a>. Citando a <a href="http://aboutwhichmorelater.tumblr.com/post/46862769549/futures-arent-ersatz-threads">Marius Eriksen</a>:</p>

<blockquote>
  <p>Futures model the real world truthfully: A Future[T] represents a T-typed result, which may or may not be delivered at some time in the future, or which may fail altogether. Like real-world asynchronous operations, a future is always in one of 3 states: incomplete, completed successfully, or completed with a failure.</p>
</blockquote>

<p>Existen diversas implementaciones de futuros en Scala: en la <a href="http://www.scala-lang.org/api/2.11.4/#scala.concurrent.Future">librería estándar</a>, y en librerias como akka, finagle y scalaz. Para efectos de esta entrada lo importante es que estas instancias implementan:</p>

<ul>
  <li>Un constructor, que permite ejecutar asíncronamente un bloque de código y envolver su resultado en un futuro.</li>
  <li>Las funciones map y flatMap que permiten manipular y componer futuros.</li>
</ul>

<p>Los futuros presentan varias ventajas:</p>

<ul>
  <li>
    <p>Se pueden componer naturalmente. El API que se deriva de tener las funciones <code>map</code> y <code>flatMap</code> es bastante rico y permite secuenciar acciones asíncronas casi de la misma forma en la que uno maneja valores en un contexto síncrono (Esto claramente no es tan simple como suena: requiere un buen entendimiento del API de Futuros). La posiblidad de componer fácilmente Futuros parece ser la razón por la cuál Twitter se decantó por ellos y por eso construyó gran parte de su infraestructura en torno a <a href="http://monkey.org/~marius/funsrv.pdf">la idea de componer comportamiento a partir de funciones</a>. En contraste parece que <a href="http://www.reddit.com/r/IAmA/comments/23s80n/we_work_on_open_source_at_twitter_ask_us_anything/ch03le5">por ahora el equipo de ingeniería de Twitter no piensa usar actores</a>.</p>
  </li>
  <li>
    <p>Solo requieren una visión local del sistema: Teniendo un <code>Future[A]</code> solamente puedo crear un nuevo valor con una función <code>A =&gt; B</code> o una función <code>A =&gt; Future[B]</code>. En cambio los actores requieren razonar como interactúa un sistema de actores, qué mensajes se le debe mandar a otro actor, qué mensajes debe manejar otro actor, etc. La modularidad de un actor depende en gran parte de un conocimiento implícito de como responde a ciertos mensajes. <a href="http://pchiusano.blogspot.com/2010/01/actors-are-not-good-concurrency-model.html">Hay quienes piensan que la modularidad de una abstracción depende de que tanto permite</a> usar <a href="http://en.wikipedia.org/wiki/Pure_function">funciones puras</a>. Para ellos los <em>side effects</em> perjudican la modularidad. La comunicación entre actores es un <em>side effect</em> gigante y bajo esa perspectiva no son muy modulares. En cambio los futuros permiten usar funciones puras en sus transformaciones y por lo tanto permiten que sean reutilizados en contextos que no requieren un conocimiento implícito de la implementación.</p>
  </li>
  <li>
    <p>En general los futuros están en consonancia con muchas  de las ideas de programación funcional. Empezando por el hecho de que exigen contener algún valor uno siempre se ve obligado a manejar transformaciones de ese valor sea con <code>map</code> o <code>flatMap</code>. Esto no quiere decir que uno no pueda hacer futuros con <em>side effects</em>. Uno perfectamente puede crear un <code>Future[Unit]</code>, es decir un <code>Future</code> sin valor dentro, por ejemplo: producto de haber imprimido en pantalla un resultado asíncrono. Entonces, si bien los Futuros no evitan que uno rompa las “reglas” de programación funcional, sí son un mecanismo de concurrencia que, a diferencia de los actores, permiten razonar sobre la transformación de un valor a partir de funciones puras. Adicionalmente los Futuros son inmutables en dos sentidos: por una parte cuando un Futuro se resuelve su valor no puede cambiar, lo que da pie a que una composición de futuros determine un grafo de ejecución y de transformación de valores. Por otra parte la mayoría del API de los Futuros no muta el estado sino que devuelve otro Futuro, lo que facilita razonar sobre ellos. En gran parte estas facilidades se dan por que los Futuros son <a href="http://www.codecommit.com/blog/ruby/monads-are-not-metaphors">monadas</a>.</p>
  </li>
  <li>
    <p>Otra ventaja, un poco relacionada con el anterior punto, es que los Futuros son declarativos. Permiten al usuario combinarlos sin que éste se preocupe de varias cosas: de qué estrategia usa el <em>pool de threads</em> que lo está ejecutando o en qué momento se ejecuta la función que se pasa por parámetro, o como combinar múltiples Futuros sin importar cuál se resuelva primero, etc… En cambio los actores requieren un mayor grado de coordinación y por lo tanto dan mayor responsabilidad (y también libertad) al usuario.</p>
  </li>
</ul>

<p>Por último los futuros tienen una desventaja considerable, que tiene que ver con los casos de uso para los cuales fueron ideados. Los futuros no son adecuados para manejar estado: por ejemplo tener estado mutable que puede ser modificado por dos futuros distintos es una receta para hacer un desastre. En general este es un corolario del consabido consejo de no compartir recursos entre <em>threads</em> distintos. Por lo tanto es difícil utilizar futuros para modelar aspectos del dominio, aspectos que por lo general requieren algún tipo de estado. En conclusión los futuros sirven para manejar concurrencia y paralelismo de funciones que carecen de estado dentro de una misma JVM. Cuando se quiere realizar distribución entre distintas maquinas o concurrencia protegiendo estado los actores representan una abstracción adecuada.</p>

<h3 id="conclusin">Conclusión</h3>

<p>Los Actores y los Futuros son dos abstracciones útiles que permiten manejar concurrencia. El uso de uno no excluye automáticamente el uso del otro. Por el contrario, usualmente son colaborativos: e.g. un Actor puede despachar trabajo a un Futuro.</p>

<p>En esta entrada analizamos las ventajas de cada uno y sus mejores casos de uso, pero cabe aclarar que el mundo de Scala es prolífico en abstracciones y hay muchas alternativas que pueden ser más adecuadas para ciertos casos de uso. Hay muchas que no mencionamos como <a href="https://www.playframework.com/documentation/2.0/Iteratees">Iteratees</a>, <a href="https://github.com/scalaz/scalaz-stream">scalaz-streams</a> y la iniciativa de <a href="http://www.reactive-streams.org/">Reactive Streams</a>.</p>

<p>El mundo de Scala y la JVM es rico, los actores y los Futuros son solo las primeras abstracciones que tenemos para explorar.</p>

<h3 id="referencias">Referencias</h3>

<ul>
  <li><a href="http://monkey.org/~marius/funsrv.pdf">Your server as a function</a></li>
  <li><a href="http://james-iry.blogspot.com/2009/04/erlang-style-actors-are-all-about.html">Erlang Style Actors Are All About Shared State</a></li>
  <li><a href="http://channel9.msdn.com/Shows/Going+Deep/Hewitt-Meijer-and-Szyperski-The-Actor-Model-everything-you-wanted-to-know-but-were-afraid-to-ask">The Actor Model (everything you wanted to know, but were afraid to ask)</a></li>
  <li><a href="http://pchiusano.blogspot.com/2010/01/actors-are-not-good-concurrency-model.html">Actors are not a good concurrency model</a></li>
  <li><a href="http://www.chrisstucchio.com/blog/2013/actors_vs_futures.html">Don’t use Actors for concurrency</a></li>
  <li><a href="http://noelwelsh.com/programming/2013/03/04/why-i-dont-like-akka-actors/">Why I Don’t Like Akka Actors</a></li>
  <li><a href="http://boundary.com/blog/2014/09/03/no-you-cant-have-a-pony/">Actors, Green Threads and CSP On The JVM – No, You Can’t Have A Pony</a></li>
  <li><a href="http://aboutwhichmorelater.tumblr.com/post/46862769549/futures-arent-ersatz-threads">Futures aren’t ersatz threads</a></li>
</ul>


    </div>
    <div class="large-4 columns left-border">
        <p class="panel">
          <p class="hide-for-small-only"><span class="subheader">Entradas</span></p>
          <ul class="side-nav no-bullet">
                  
            <li>&#187; <a class="hide-for-small-only" href="/2015/09/01/T%C3%ADtulo%20escandaloso_sobre%20los_desarrolladores_colombianos.html">Título escandaloso sobre los desarrolladores colombianos*</a></li>
                  
            <li>&#187; <a class="hide-for-small-only" href="/2014/11/18/futuros_y_actores.html">Futuros y actores en Scala y Akka</a></li>
                  
            <li>&#187; <a class="hide-for-small-only" href="/2014/03/09/consistencia.html">Consistencia</a></li>
                  
            <li>&#187; <a class="hide-for-small-only" href="/2013/09/21/soa_agil.html">SOA ágil</a></li>
                  
            <li>&#187; <a class="hide-for-small-only" href="/2013/05/07/bus_de_eventos_de_dominio.html">Bus de eventos de dominio</a></li>
                  
            <li>&#187; <a class="hide-for-small-only" href="/2013/04/13/simpatia_semantica.html">Simpatía semántica</a></li>
                  
            <li>&#187; <a class="hide-for-small-only" href="/2013/02/23/pareto_arquitectura_y_scrum.html">Arquitectura, DDD y Scrum.</a></li>
                  
            <li>&#187; <a class="hide-for-small-only" href="/2012/04/24/no_bpms.html">No, su proyecto no necesita BPMS</a></li>
                  
            <li>&#187; <a class="hide-for-small-only" href="/2011/10/17/patron_estados_observados.html">Patrón de estados observados</a></li>
                  
            <li>&#187; <a class="hide-for-small-only" href="/2011/07/22/soa_no_es_esb.html">SOA != ESB</a></li>
                    
          </ul>
        </p>
        <p class="hide-for-small-only"><span class="subheader">Social </span></p>
          <ul class="side-nav no-bullet">
            <li>» <a class="hide-for-small-only" href="https://bitacora.s3.amazonaws.com/me.html">El autor</a></li>
            <li>» <a class="hide-for-small-only" href="http://twitter.com/ykiriki">@ykiriki</a></li>
            <li>» <a class="hide-for-small-only" href="/atom.xml">Atom 1.0</a></li>
          </ul>
        </p>        
    </div>    
  </div>
  <div class="row">
    <div class="large-12 columns">
      <div id="disqus_thread"></div>bitacora/
        <script type="text/javascript">
          var disqus_shortname = 'bitcora';
          var disqus_identifier = 'http://yujikiriki.com/2014/11/18/futuros_y_actores';
          var disqus_url = 'http://yujikiriki.com/2014/11/18/futuros_y_actores.html';

          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
      </div>
    </div>
  </div>
<!-- Foundation dependencies -->
    <script src="http://yujikiriki.github.io/js/vendor/jquery.js"></script>
    <script src="http://yujikiriki.github.io/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
    </script>
<!-- Google analytics -->
<!-- 
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-24796665-1']);
    _gaq.push(['_trackPageview']);
    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
   -->    
  </body>
</html>
